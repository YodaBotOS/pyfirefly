<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyfirefly API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pyfirefly</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import aiohttp
import asyncio
import json
import random
import time
import uuid
from typing import (
    Awaitable,
    Optional
)

from .exceptions import (
        ImageGenerationDenied,
        Unauthorized,
        SessionExpired
)

class _Latin1BodyPartReader(aiohttp.multipart.BodyPartReader):
    async def text(self) -&gt; Awaitable[str]:
        data = await self.read(decode=True)
        return data.decode(&#39;latin1&#39;)

class _Latin1MultipartReader(aiohttp.multipart.MultipartReader):
    async def next(self) -&gt; Optional[_Latin1BodyPartReader]:
        part_reader = await super().next()
        if part_reader is not None:
            part_reader.__class__ = _Latin1BodyPartReader
        return part_reader

class Result:
        &#39;&#39;&#39;
        Represents a result from the Adobe Firefly API.

        Parameters
        ----------
        image: bytes
                The image data.
        ext: str
                The image extension.
        metadata: dict
                The metadata.
        img_options: dict
                The image options that were used to generate the image.
        &#39;&#39;&#39;
        __slots__ = [&#39;image&#39;, &#39;ext&#39;, &#39;metadata&#39;, &#39;img_options&#39;]
        def __init__(self, image: bytes, metadata: dict, ext: str, img_options: dict):
                self.image = image
                self.ext = ext
                self.metadata = metadata
                self.img_options = img_options

class Firefly:
        &#39;&#39;&#39;
        Reverse engineered Adobe Firefly API.

        Parameters
        ----------
        auth: str
                The authorization bearer token to use.
        build: str, optional
                The build to use. Can be one of &#39;dev&#39;, &#39;stage&#39;, or &#39;prod&#39;. Defaults to &#39;prod&#39;.
        anonymous: bool, optional
                Whether to use anonymous mode. Not supported yet.
        fetch_image_assets: bool, optional
                Whether to fetch image assets. Defaults to True.
        fetch_text_assets: bool, optional
                Whether to fetch text assets. Defaults to True.
    &#39;&#39;&#39;
        __slots__ = [&#39;headers&#39;, &#39;base&#39;, &#39;engine&#39;, &#39;session&#39;, &#39;image_styles&#39;, &#39;text_presets&#39;, &#39;text_fonts&#39;]

        URLS = {
                &#39;default&#39;: {
                        &#39;dev&#39;: &#39;https://senseicore-stage-ue1.adobe.io/services/&#39;,
                        &#39;stage&#39;: &#39;https://senseicore-stage-ue1.adobe.io/services/&#39;,
                        &#39;prod&#39;: &#39;https://sensei-ue1.adobe.io/services/&#39;
                },
                &#39;anonymous&#39;: {
                        &#39;dev&#39;: &#39;https://senseicore-stage-ue1.adobe.io/anonymous/&#39;,
                        &#39;stage&#39;: &#39;https://senseicore-stage-ue1.adobe.io/anonymous/&#39;,
                        &#39;prod&#39;: &#39;https://sensei-ue1.adobe.io/anonymous/&#39;
                }
        }

        DIFFUSION_ENGINES = {
                &#39;dev&#39;: &#39;Classification:diffusion-service:Service-943088ea714543dd8289374cd1e92bb6&#39;,
                &#39;stage&#39;: &#39;Classification:diffusion-service:Service-7367c21c82b946e7adb3995315de18a8&#39;,
                &#39;prod&#39;: &#39;Classification:diffusion-service:Service-c742bc2eaae1491987dc00daff32fc07&#39;
        }

        ASSET_BASE_URL = &#34;https://clio-assets.adobe.com/clio-playground/&#34;

        #https://stackoverflow.com/a/45364670
        async def __new__(cls, *args, **kwargs):
                instance = super().__new__(cls)
                await instance.__init__(*args, **kwargs)
                return instance

        async def __init__(self, auth: str, build: str=&#39;prod&#39;, anonymous: bool=False, fetch_image_assets: bool=True, fetch_text_assets: bool=True):
                if anonymous:
                        raise NotImplementedError(&#39;Anonymous mode not supported yet.&#39;)
                
                self.headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;Accept&#39;: &#39;multipart/form-data&#39;,
                        &#39;Authorization&#39;: &#39;Bearer &#39;+auth.strip(),
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;,
                        &#39;x-api-key&#39;: &#39;clio-playground-web&#39;
                }

                dif_type = &#39;anonymous&#39; if anonymous else &#39;default&#39;
                prod_url = Firefly.URLS[dif_type][&#39;prod&#39;]
                self.base = Firefly.URLS[dif_type].get(build, prod_url)

                prod_engine = Firefly.DIFFUSION_ENGINES[&#39;prod&#39;]
                self.engine = Firefly.DIFFUSION_ENGINES.get(build, prod_engine)

                self.session = {
                        &#39;id&#39;: None,
                        &#39;expires_at&#39;: 0
                }

                asset_tasks = []
                if fetch_image_assets:
                        asset_tasks.append(Firefly._get_image_styles())
                if fetch_text_assets:
                        asset_tasks.append(Firefly._get_text_presets())
                        asset_tasks.append(Firefly._get_text_fonts())
                
                if asset_tasks:
                        assets = await asyncio.gather(*asset_tasks)
                        for a in assets:
                                if &#39;styles&#39; in a:
                                        self.image_styles = a[&#39;styles&#39;]
                                elif &#39;presets&#39; in a:
                                        self.text_presets = a[&#39;presets&#39;]
                                elif &#39;fonts&#39; in a:
                                        self.text_fonts = a[&#39;fonts&#39;]

                await self.create_session()

        @property
        def has_time_left(self) -&gt; bool:
                &#39;&#39;&#39;
                Whether the session has time left.
                &#39;&#39;&#39;
                return time.time() - self.session[&#39;expires_at&#39;] &lt;= 0

        @staticmethod
        async def _get_image_styles() -&gt; list[dict]:
                &#39;&#39;&#39;
                Gets the image styles.
                &#39;&#39;&#39;
                url = f&#39;{Firefly.ASSET_BASE_URL}image-styles/v4/en-US/content.json&#39;
                headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;
                }
                async with aiohttp.ClientSession(headers=headers) as s:
                        async with s.get(url) as resp:
                                data = await resp.json()
                                return data

        @staticmethod
        async def _get_text_presets() -&gt; list[dict]:
                &#39;&#39;&#39;
                Gets the text presets.
                &#39;&#39;&#39;
                url = f&#39;{Firefly.ASSET_BASE_URL}text-presets/v3/en-US/content.json&#39;
                headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;
                }
                async with aiohttp.ClientSession(headers=headers) as s:
                        async with s.get(url) as resp:
                                data = await resp.json()
                                return data

        @staticmethod
        async def _get_text_fonts() -&gt; list[dict]:
                &#39;&#39;&#39;
                Gets the text fonts.
                &#39;&#39;&#39;
                url = f&#39;{Firefly.ASSET_BASE_URL}text-fonts/v2/en-US/content.json&#39;
                headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;
                }
                async with aiohttp.ClientSession(headers=headers) as s:
                        async with s.get(url) as resp:
                                data = await resp.json()
                                return data

        @staticmethod
        def _check_gen_status(metadata: dict) -&gt; None:
                values = metadata[&#39;values&#39;]
                if values.get(&#39;gi_GEN_STATUS&#39;):
                        status = values[&#39;gi_GEN_STATUS&#39;][&#39;value&#39;]
                else:
                        status = values[&#39;gt_GEN_STATUS&#39;][&#39;value&#39;]
                if bool(1 &amp; status):
                        raise ImageGenerationDenied(&#39;Denied&#39;)
                elif bool(2 &amp; status):
                        raise ImageGenerationDenied(&#39;BlockedClassNSFW&#39;)
                elif bool(4 &amp; status):
                        raise ImageGenerationDenied(&#39;BlockedClassArtist&#39;)
                elif bool(8 &amp; status):
                        raise ImageGenerationDenied(&#39;DeniedSilent&#39;)
                elif bool(16 &amp; status):
                        raise ImageGenerationDenied(&#39;NotEnglish&#39;)
                elif bool(32 &amp; status):
                        raise ImageGenerationDenied(&#39;PostProcessingNSFW&#39;)

        async def create_session(self, duration:int = 3600) -&gt; str:
                &#39;&#39;&#39;
                Creates a session.

                Parameters
                ----------
                duration: The duration of the session in seconds.

                Returns
                -------
                The session ID string.
                &#39;&#39;&#39;
                url = f&#39;{self.base}session/create&#39;

                formdata = aiohttp.FormData()
                formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps({&#39;session_ttl&#39;:duration}), content_type=&#39;form-data&#39;)

                async with aiohttp.ClientSession(headers=self.headers) as s:
                        async with s.post(url, data=formdata) as resp:
                                if resp.status == 401:
                                        raise Unauthorized(&#39;Bearer auth token is invalid.&#39;)
                                self.session[&#39;id&#39;] = resp.headers.get(&#39;x-session-id&#39;, &#39;&#39;)
                                if self.session[&#39;id&#39;]:
                                        self.session[&#39;expires_at&#39;] = time.time() + duration
                                return self.session[&#39;id&#39;]

        async def text_to_image(self, prompt: str, **kwargs) -&gt; Result:
                &#39;&#39;&#39;
                Generates an image from a text prompt.

                Parameters
                ----------
                prompt: str
                        The text prompt.
                seed: int, optional
                        The seed for the image generation. Default is random.
                style_prompt: str, optional
                        The style prompt for the image generation. Default is None.
                anchor_prompt: str, optional
                        The anchor prompt for the image generation. Default is None.
                steps: int, optional
                        The number of inference steps. Default is 40.
                width: int,     optional
                        The width of the image. Default is 1024.
                height: int, optional
                        The height of the image. Default is 1024.
                fix_face: bool, optional
                        Whether to fix the face. Default is True.
                
                Returns
                -------
                pyfirefly.Result

                Raises
                ------
                pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied
                &#39;&#39;&#39;
                if not self.has_time_left:
                        raise SessionExpired(&#39;Create a new session using `await create_session()`. You can check for time left using `has_time_left`.&#39;)

                url = f&#39;{self.base}v2/predict&#39;

                seed = kwargs.get(&#39;seed&#39;, random.randint(0, 100000))

                style_prompt = kwargs.get(&#39;style_prompt&#39;)
                anchor_prompt = kwargs.get(&#39;anchor_prompt&#39;)
                advanced_options = { &#39;num_inference_steps&#39;: kwargs.get(&#39;steps&#39;, 40) }
                if style_prompt:
                        advanced_options[&#39;style_prompt&#39;] = style_prompt
                if anchor_prompt:
                        advanced_options[&#39;anchor_prompt&#39;] = anchor_prompt
                
                settings = {
                        &#39;sensei:name&#39;: &#39;SelectionParse v2&#39;,
                        &#39;sensei:invocation_mode&#39;: &#39;synchronous&#39;,
                        &#39;sensei:invocation_batch&#39;: False,
                        &#39;sensei:in_response&#39;: False,
                        &#39;sensei:engines&#39;: [
                                {
                                        &#39;sensei:execution_info&#39;: {
                                                &#39;sensei:engine&#39;: self.engine
                                        },
                                        &#39;sensei:inputs&#39;: {},
                                        &#39;sensei:outputs&#39;: {
                                                &#39;spl:response&#39;: {
                                                        &#39;dc:format&#39;: &#39;application/json&#39;,
                                                        &#39;sensei:multipart_field_name&#39;: &#39;spl:response&#39;,
                                                },
                                                &#39;gt_GEN_IMAGE&#39;: {
                                                        &#39;dc:format&#39;: &#39;image/jpeg&#39;,
                                                        &#39;sensei:multipart_field_name&#39;: &#39;outfile&#39;,
                                                },
                                        },
                                        &#39;sensei:params&#39;: {
                                                &#39;spl:request&#39;: {
                                                        &#39;graph&#39;: {&#39;uri&#39;: &#39;urn:graph:Text2Image_v2&#39;},
                                                        &#39;params&#39;: [
                                                                {&#39;name&#39;: &#39;gi_SEED&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: seed},
                                                                {&#39;name&#39;: &#39;gi_NUM_STEPS&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;steps&#39;, 40)},
                                                                {&#39;name&#39;: &#39;gi_OUTPUT_WIDTH&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;width&#39;, 1024)},
                                                                {&#39;name&#39;: &#39;gi_OUTPUT_HEIGHT&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;height&#39;, 1024)},
                                                                {
                                                                        &#39;name&#39;: &#39;gi_ADVANCED&#39;,
                                                                        &#39;type&#39;: &#39;string&#39;,
                                                                        &#39;value&#39;: json.dumps(advanced_options),
                                                                },
                                                                {&#39;name&#39;: &#39;gi_LANGUAGE&#39;, &#39;type&#39;: &#39;string&#39;, &#39;value&#39;: &#39;en-US&#39;},
                                                                {&#39;name&#39;: &#39;gi_USE_FACE_FIX&#39;, &#39;type&#39;: &#39;boolean&#39;, &#39;value&#39;: kwargs.get(&#39;fix_face&#39;, True)},
                                                        ],
                                                        &#39;inputs&#39;: {
                                                                &#39;gi_PROMPT&#39;: {
                                                                        &#39;id&#39;: str(uuid.uuid4()),
                                                                        &#39;type&#39;: &#39;string&#39;,
                                                                        &#39;value&#39;: prompt,
                                                                }
                                                        },
                                                        &#39;outputs&#39;: {
                                                                &#39;gt_GEN_IMAGE&#39;: {
                                                                        &#39;id&#39;: str(uuid.uuid4()),
                                                                        &#39;type&#39;: &#39;image&#39;,
                                                                        &#39;expectedMimeType&#39;: &#39;image/jpeg&#39;,
                                                                },
                                                                &#39;gt_GEN_STATUS&#39;: {
                                                                        &#39;id&#39;: str(uuid.uuid4()),
                                                                        &#39;type&#39;: &#39;scalar&#39;,
                                                                },
                                                        },
                                                }
                                        },
                                }
                        ],
                }

                formdata = aiohttp.FormData()
                formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps(settings), content_type=&#39;form-data&#39;)

                new_headers = dict(self.headers)
                new_headers[&#39;x-session-id&#39;] = self.session[&#39;id&#39;]
                new_headers[&#39;x-transaction-id&#39;] = str(uuid.uuid4())
                new_headers[&#39;prefer&#39;] = &#39;respond-sync, wait=100&#39;

                async with aiohttp.ClientSession(headers=new_headers) as s:
                        async with s.post(url, headers=new_headers, data=formdata) as resp:
                                if resp.status == 401:
                                        raise Unauthorized(&#39;Unauthorized. Bearer auth token is invalid.&#39;)
                                reader = _Latin1MultipartReader(resp.headers, resp.content)
                                metadata = None
                                image = None
                                while True:
                                        part = await reader.next()
                                        if part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;application/json&#39;:
                                                metadata = await part.json()
                                        elif part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;image/jpeg&#39;:
                                                image = await part.read(decode=False)
                                        if metadata and image:
                                                break

                                # Check if the image generation was successful
                                Firefly._check_gen_status(metadata)

                                gen_options = {
                                        &#39;seed&#39;: seed,
                                        &#39;style_prompt&#39;: kwargs.get(&#39;style_prompt&#39;),
                                        &#39;anchor_prompt&#39;: kwargs.get(&#39;anchor_prompt&#39;),
                                        &#39;steps&#39;: kwargs.get(&#39;steps&#39;, 40),
                                        &#39;width&#39;: kwargs.get(&#39;width&#39;, 1024),
                                        &#39;height&#39;: kwargs.get(&#39;height&#39;, 1024),
                                        &#39;fix_face&#39;: kwargs.get(&#39;fix_face&#39;, True)
                                }
                                return Result(image, metadata, &#39;jpeg&#39;, gen_options)

        async def glyph_to_image(self, glyph: bytes, **kwargs) -&gt; Result:
                &#39;&#39;&#39;
                Generates an image from a glyph (webp image data) and prompt.

                Parameters
                ----------
                glyph: bytes
                        The glyph to use. Must be a webp image (bytes). The non-transparent pixels will be filled in by Adobe Firefly.
                description: str
                        Describe the text/fill effects you want to generate.
                seed: int, optional
                        The seed for the image generation. Default is random.
                steps: int, optional
                        The number of inference steps. Default is 30.
                width: int, optional
                        The width of the image. Default is 1024.
                height: int, optional
                        The height of the image. Default is 1024.
                pad_ratio: float, optional
                        The padding ratio. Default is 0.5.
                strength: float, optional
                        between 0.0 and 1.0, higher values cause more variations but potentially inconsistent outcomes. Default is 0.5. See https://github.com/CompVis/stable-diffusion/blob/main/README.md for more info.

                Returns
                -------
                pyfirefly.Result
                
                Raises
                ------
                pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied
                &#39;&#39;&#39;
                if not self.has_time_left:
                        raise SessionExpired(&#39;Create a new session using `await create_session()`. You can check for time left using `has_time_left`.&#39;)

                if not kwargs.get(&#39;description&#39;):
                        raise ValueError(&#39;You must provide a description.&#39;)

                url = f&#39;{self.base}v2/predict&#39;

                seed = kwargs.get(&#39;seed&#39;, random.randint(0, 100000))
                advanced_options = { &#39;num_inference_steps&#39;: kwargs.get(&#39;steps&#39;, 30) }

                settings = {
                        &#34;sensei:name&#34;: &#34;SelectionParse v2&#34;,
                        &#34;sensei:invocation_mode&#34;: &#34;synchronous&#34;,
                        &#34;sensei:invocation_batch&#34;: False,
                        &#34;sensei:in_response&#34;: False,
                        &#34;sensei:engines&#34;: [
                                {
                                        &#34;sensei:execution_info&#34;: {
                                                &#34;sensei:engine&#34;: self.engine
                                        },
                                        &#34;sensei:inputs&#34;: {
                                                &#34;gi_GLYPHMASK&#34;: {
                                                        &#34;dc:format&#34;: &#34;image/webp&#34;,
                                                        &#34;sensei:multipart_field_name&#34;: &#34;gi_GLYPHMASK&#34;,
                                                }
                                        },
                                        &#34;sensei:outputs&#34;: {
                                                &#34;spl:response&#34;: {
                                                        &#34;dc:format&#34;: &#34;application/json&#34;,
                                                        &#34;sensei:multipart_field_name&#34;: &#34;spl:response&#34;,
                                                },
                                                &#34;gi_GEN_IMAGE&#34;: {
                                                        &#34;dc:format&#34;: &#34;image/webp&#34;,
                                                        &#34;sensei:multipart_field_name&#34;: &#34;outfile&#34;,
                                                },
                                        },
                                        &#34;sensei:params&#34;: {
                                                &#34;spl:request&#34;: {
                                                        &#34;graph&#34;: {&#34;uri&#34;: &#34;urn:graph:Glyph2Image_v2&#34;},
                                                        &#34;params&#34;: [
                                                                {&#34;name&#34;: &#34;gi_SEED&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: seed},
                                                                {&#34;name&#34;: &#34;gi_NUM_STEPS&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;steps&#39;, 30) },
                                                                {&#34;name&#34;: &#34;gi_OUTPUT_WIDTH&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;width&#39;, 1024) },
                                                                {&#34;name&#34;: &#34;gi_OUTPUT_HEIGHT&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;height&#39;, 1024) },
                                                                {
                                                                        &#34;name&#34;: &#34;gi_ADVANCED&#34;,
                                                                        &#34;type&#34;: &#34;string&#34;,
                                                                        &#34;value&#34;: json.dumps(advanced_options),
                                                                },
                                                                {&#34;name&#34;: &#34;gi_LANGUAGE&#34;, &#34;type&#34;: &#34;string&#34;, &#34;value&#34;: &#34;en-us&#34;},
                                                                {&#34;name&#34;: &#34;gi_PAD_RATIO&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;pad_ratio&#39;, -1)},
                                                                {&#34;name&#34;: &#34;gi_STRENGTH&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;strength&#39;, 0.5) },
                                                        ],
                                                        &#34;inputs&#34;: {
                                                                &#34;gi_PROMPT&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;string&#34;,
                                                                        &#34;value&#34;: kwargs.get(&#39;description&#39;),
                                                                },
                                                                &#34;gi_GLYPHMASK&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;image&#34;,
                                                                        &#34;mimeType&#34;: &#34;image/webp&#34;,
                                                                },
                                                        },
                                                        &#34;outputs&#34;: {
                                                                &#34;gi_GEN_IMAGE&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;image&#34;,
                                                                        &#34;expectedMimeType&#34;: &#34;image/webp&#34;,
                                                                },
                                                                &#34;gi_GEN_STATUS&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;scalar&#34;,
                                                                },
                                                        },
                                                }
                                        },
                                }
                        ],
                }

                formdata = aiohttp.FormData()
                formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps(settings), content_type=&#39;form-data&#39;)
                formdata.add_field(&#39;gi_GLYPHMASK&#39;, glyph, filename=&#39;blob&#39;, content_type=&#39;image/webp&#39;)

                new_headers = dict(self.headers)
                new_headers[&#39;x-session-id&#39;] = self.session[&#39;id&#39;]
                new_headers[&#39;x-transaction-id&#39;] = str(uuid.uuid4())
                new_headers[&#39;prefer&#39;] = &#39;respond-sync, wait=100&#39;

                async with aiohttp.ClientSession(headers=new_headers) as s:
                        async with s.post(url, headers=new_headers, data=formdata) as resp:
                                if resp.status == 401:
                                        raise Unauthorized(&#39;Unauthorized. Bearer auth token is invalid.&#39;)
                                reader = _Latin1MultipartReader(resp.headers, resp.content)
                                metadata = None
                                image = None
                                while True:
                                        part = await reader.next()
                                        if part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;application/json&#39;:
                                                metadata = await part.json()
                                        elif part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;image/webp&#39;:
                                                image = await part.read(decode=False)
                                        if metadata and image:
                                                break

                                # Check if the image generation was successful
                                Firefly._check_gen_status(metadata)

                                gen_options = {
                                        &#39;description&#39;: kwargs.get(&#39;description&#39;),
                                        &#39;seed&#39;: seed,
                                        &#39;steps&#39;: kwargs.get(&#39;steps&#39;, 30),
                                        &#39;width&#39;: kwargs.get(&#39;width&#39;, 1024),
                                        &#39;height&#39;: kwargs.get(&#39;height&#39;, 1024),
                                        &#39;pad_ratio&#39;: kwargs.get(&#39;pad_ratio&#39;, -1),
                                        &#39;strength&#39;: kwargs.get(&#39;strength&#39;, 0.5)
                                }
                                return Result(image, metadata, &#39;webp&#39;, gen_options)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyfirefly.exceptions" href="exceptions.html">pyfirefly.exceptions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyfirefly.utils" href="utils.html">pyfirefly.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyfirefly.Firefly"><code class="flex name class">
<span>class <span class="ident">Firefly</span></span>
<span>(</span><span>auth: str, build: str = 'prod', anonymous: bool = False, fetch_image_assets: bool = True, fetch_text_assets: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reverse engineered Adobe Firefly API.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>auth</code></strong> :&ensp;<code>str</code></dt>
<dd>The authorization bearer token to use.</dd>
<dt><strong><code>build</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The build to use. Can be one of 'dev', 'stage', or 'prod'. Defaults to 'prod'.</dd>
<dt><strong><code>anonymous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use anonymous mode. Not supported yet.</dd>
<dt><strong><code>fetch_image_assets</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fetch image assets. Defaults to True.</dd>
<dt><strong><code>fetch_text_assets</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fetch text assets. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Firefly:
        &#39;&#39;&#39;
        Reverse engineered Adobe Firefly API.

        Parameters
        ----------
        auth: str
                The authorization bearer token to use.
        build: str, optional
                The build to use. Can be one of &#39;dev&#39;, &#39;stage&#39;, or &#39;prod&#39;. Defaults to &#39;prod&#39;.
        anonymous: bool, optional
                Whether to use anonymous mode. Not supported yet.
        fetch_image_assets: bool, optional
                Whether to fetch image assets. Defaults to True.
        fetch_text_assets: bool, optional
                Whether to fetch text assets. Defaults to True.
    &#39;&#39;&#39;
        __slots__ = [&#39;headers&#39;, &#39;base&#39;, &#39;engine&#39;, &#39;session&#39;, &#39;image_styles&#39;, &#39;text_presets&#39;, &#39;text_fonts&#39;]

        URLS = {
                &#39;default&#39;: {
                        &#39;dev&#39;: &#39;https://senseicore-stage-ue1.adobe.io/services/&#39;,
                        &#39;stage&#39;: &#39;https://senseicore-stage-ue1.adobe.io/services/&#39;,
                        &#39;prod&#39;: &#39;https://sensei-ue1.adobe.io/services/&#39;
                },
                &#39;anonymous&#39;: {
                        &#39;dev&#39;: &#39;https://senseicore-stage-ue1.adobe.io/anonymous/&#39;,
                        &#39;stage&#39;: &#39;https://senseicore-stage-ue1.adobe.io/anonymous/&#39;,
                        &#39;prod&#39;: &#39;https://sensei-ue1.adobe.io/anonymous/&#39;
                }
        }

        DIFFUSION_ENGINES = {
                &#39;dev&#39;: &#39;Classification:diffusion-service:Service-943088ea714543dd8289374cd1e92bb6&#39;,
                &#39;stage&#39;: &#39;Classification:diffusion-service:Service-7367c21c82b946e7adb3995315de18a8&#39;,
                &#39;prod&#39;: &#39;Classification:diffusion-service:Service-c742bc2eaae1491987dc00daff32fc07&#39;
        }

        ASSET_BASE_URL = &#34;https://clio-assets.adobe.com/clio-playground/&#34;

        #https://stackoverflow.com/a/45364670
        async def __new__(cls, *args, **kwargs):
                instance = super().__new__(cls)
                await instance.__init__(*args, **kwargs)
                return instance

        async def __init__(self, auth: str, build: str=&#39;prod&#39;, anonymous: bool=False, fetch_image_assets: bool=True, fetch_text_assets: bool=True):
                if anonymous:
                        raise NotImplementedError(&#39;Anonymous mode not supported yet.&#39;)
                
                self.headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;Accept&#39;: &#39;multipart/form-data&#39;,
                        &#39;Authorization&#39;: &#39;Bearer &#39;+auth.strip(),
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;,
                        &#39;x-api-key&#39;: &#39;clio-playground-web&#39;
                }

                dif_type = &#39;anonymous&#39; if anonymous else &#39;default&#39;
                prod_url = Firefly.URLS[dif_type][&#39;prod&#39;]
                self.base = Firefly.URLS[dif_type].get(build, prod_url)

                prod_engine = Firefly.DIFFUSION_ENGINES[&#39;prod&#39;]
                self.engine = Firefly.DIFFUSION_ENGINES.get(build, prod_engine)

                self.session = {
                        &#39;id&#39;: None,
                        &#39;expires_at&#39;: 0
                }

                asset_tasks = []
                if fetch_image_assets:
                        asset_tasks.append(Firefly._get_image_styles())
                if fetch_text_assets:
                        asset_tasks.append(Firefly._get_text_presets())
                        asset_tasks.append(Firefly._get_text_fonts())
                
                if asset_tasks:
                        assets = await asyncio.gather(*asset_tasks)
                        for a in assets:
                                if &#39;styles&#39; in a:
                                        self.image_styles = a[&#39;styles&#39;]
                                elif &#39;presets&#39; in a:
                                        self.text_presets = a[&#39;presets&#39;]
                                elif &#39;fonts&#39; in a:
                                        self.text_fonts = a[&#39;fonts&#39;]

                await self.create_session()

        @property
        def has_time_left(self) -&gt; bool:
                &#39;&#39;&#39;
                Whether the session has time left.
                &#39;&#39;&#39;
                return time.time() - self.session[&#39;expires_at&#39;] &lt;= 0

        @staticmethod
        async def _get_image_styles() -&gt; list[dict]:
                &#39;&#39;&#39;
                Gets the image styles.
                &#39;&#39;&#39;
                url = f&#39;{Firefly.ASSET_BASE_URL}image-styles/v4/en-US/content.json&#39;
                headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;
                }
                async with aiohttp.ClientSession(headers=headers) as s:
                        async with s.get(url) as resp:
                                data = await resp.json()
                                return data

        @staticmethod
        async def _get_text_presets() -&gt; list[dict]:
                &#39;&#39;&#39;
                Gets the text presets.
                &#39;&#39;&#39;
                url = f&#39;{Firefly.ASSET_BASE_URL}text-presets/v3/en-US/content.json&#39;
                headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;
                }
                async with aiohttp.ClientSession(headers=headers) as s:
                        async with s.get(url) as resp:
                                data = await resp.json()
                                return data

        @staticmethod
        async def _get_text_fonts() -&gt; list[dict]:
                &#39;&#39;&#39;
                Gets the text fonts.
                &#39;&#39;&#39;
                url = f&#39;{Firefly.ASSET_BASE_URL}text-fonts/v2/en-US/content.json&#39;
                headers = {
                        &#39;Origin&#39;: &#39;https://firefly.adobe.com&#39;,
                        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&#39;
                }
                async with aiohttp.ClientSession(headers=headers) as s:
                        async with s.get(url) as resp:
                                data = await resp.json()
                                return data

        @staticmethod
        def _check_gen_status(metadata: dict) -&gt; None:
                values = metadata[&#39;values&#39;]
                if values.get(&#39;gi_GEN_STATUS&#39;):
                        status = values[&#39;gi_GEN_STATUS&#39;][&#39;value&#39;]
                else:
                        status = values[&#39;gt_GEN_STATUS&#39;][&#39;value&#39;]
                if bool(1 &amp; status):
                        raise ImageGenerationDenied(&#39;Denied&#39;)
                elif bool(2 &amp; status):
                        raise ImageGenerationDenied(&#39;BlockedClassNSFW&#39;)
                elif bool(4 &amp; status):
                        raise ImageGenerationDenied(&#39;BlockedClassArtist&#39;)
                elif bool(8 &amp; status):
                        raise ImageGenerationDenied(&#39;DeniedSilent&#39;)
                elif bool(16 &amp; status):
                        raise ImageGenerationDenied(&#39;NotEnglish&#39;)
                elif bool(32 &amp; status):
                        raise ImageGenerationDenied(&#39;PostProcessingNSFW&#39;)

        async def create_session(self, duration:int = 3600) -&gt; str:
                &#39;&#39;&#39;
                Creates a session.

                Parameters
                ----------
                duration: The duration of the session in seconds.

                Returns
                -------
                The session ID string.
                &#39;&#39;&#39;
                url = f&#39;{self.base}session/create&#39;

                formdata = aiohttp.FormData()
                formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps({&#39;session_ttl&#39;:duration}), content_type=&#39;form-data&#39;)

                async with aiohttp.ClientSession(headers=self.headers) as s:
                        async with s.post(url, data=formdata) as resp:
                                if resp.status == 401:
                                        raise Unauthorized(&#39;Bearer auth token is invalid.&#39;)
                                self.session[&#39;id&#39;] = resp.headers.get(&#39;x-session-id&#39;, &#39;&#39;)
                                if self.session[&#39;id&#39;]:
                                        self.session[&#39;expires_at&#39;] = time.time() + duration
                                return self.session[&#39;id&#39;]

        async def text_to_image(self, prompt: str, **kwargs) -&gt; Result:
                &#39;&#39;&#39;
                Generates an image from a text prompt.

                Parameters
                ----------
                prompt: str
                        The text prompt.
                seed: int, optional
                        The seed for the image generation. Default is random.
                style_prompt: str, optional
                        The style prompt for the image generation. Default is None.
                anchor_prompt: str, optional
                        The anchor prompt for the image generation. Default is None.
                steps: int, optional
                        The number of inference steps. Default is 40.
                width: int,     optional
                        The width of the image. Default is 1024.
                height: int, optional
                        The height of the image. Default is 1024.
                fix_face: bool, optional
                        Whether to fix the face. Default is True.
                
                Returns
                -------
                pyfirefly.Result

                Raises
                ------
                pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied
                &#39;&#39;&#39;
                if not self.has_time_left:
                        raise SessionExpired(&#39;Create a new session using `await create_session()`. You can check for time left using `has_time_left`.&#39;)

                url = f&#39;{self.base}v2/predict&#39;

                seed = kwargs.get(&#39;seed&#39;, random.randint(0, 100000))

                style_prompt = kwargs.get(&#39;style_prompt&#39;)
                anchor_prompt = kwargs.get(&#39;anchor_prompt&#39;)
                advanced_options = { &#39;num_inference_steps&#39;: kwargs.get(&#39;steps&#39;, 40) }
                if style_prompt:
                        advanced_options[&#39;style_prompt&#39;] = style_prompt
                if anchor_prompt:
                        advanced_options[&#39;anchor_prompt&#39;] = anchor_prompt
                
                settings = {
                        &#39;sensei:name&#39;: &#39;SelectionParse v2&#39;,
                        &#39;sensei:invocation_mode&#39;: &#39;synchronous&#39;,
                        &#39;sensei:invocation_batch&#39;: False,
                        &#39;sensei:in_response&#39;: False,
                        &#39;sensei:engines&#39;: [
                                {
                                        &#39;sensei:execution_info&#39;: {
                                                &#39;sensei:engine&#39;: self.engine
                                        },
                                        &#39;sensei:inputs&#39;: {},
                                        &#39;sensei:outputs&#39;: {
                                                &#39;spl:response&#39;: {
                                                        &#39;dc:format&#39;: &#39;application/json&#39;,
                                                        &#39;sensei:multipart_field_name&#39;: &#39;spl:response&#39;,
                                                },
                                                &#39;gt_GEN_IMAGE&#39;: {
                                                        &#39;dc:format&#39;: &#39;image/jpeg&#39;,
                                                        &#39;sensei:multipart_field_name&#39;: &#39;outfile&#39;,
                                                },
                                        },
                                        &#39;sensei:params&#39;: {
                                                &#39;spl:request&#39;: {
                                                        &#39;graph&#39;: {&#39;uri&#39;: &#39;urn:graph:Text2Image_v2&#39;},
                                                        &#39;params&#39;: [
                                                                {&#39;name&#39;: &#39;gi_SEED&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: seed},
                                                                {&#39;name&#39;: &#39;gi_NUM_STEPS&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;steps&#39;, 40)},
                                                                {&#39;name&#39;: &#39;gi_OUTPUT_WIDTH&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;width&#39;, 1024)},
                                                                {&#39;name&#39;: &#39;gi_OUTPUT_HEIGHT&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;height&#39;, 1024)},
                                                                {
                                                                        &#39;name&#39;: &#39;gi_ADVANCED&#39;,
                                                                        &#39;type&#39;: &#39;string&#39;,
                                                                        &#39;value&#39;: json.dumps(advanced_options),
                                                                },
                                                                {&#39;name&#39;: &#39;gi_LANGUAGE&#39;, &#39;type&#39;: &#39;string&#39;, &#39;value&#39;: &#39;en-US&#39;},
                                                                {&#39;name&#39;: &#39;gi_USE_FACE_FIX&#39;, &#39;type&#39;: &#39;boolean&#39;, &#39;value&#39;: kwargs.get(&#39;fix_face&#39;, True)},
                                                        ],
                                                        &#39;inputs&#39;: {
                                                                &#39;gi_PROMPT&#39;: {
                                                                        &#39;id&#39;: str(uuid.uuid4()),
                                                                        &#39;type&#39;: &#39;string&#39;,
                                                                        &#39;value&#39;: prompt,
                                                                }
                                                        },
                                                        &#39;outputs&#39;: {
                                                                &#39;gt_GEN_IMAGE&#39;: {
                                                                        &#39;id&#39;: str(uuid.uuid4()),
                                                                        &#39;type&#39;: &#39;image&#39;,
                                                                        &#39;expectedMimeType&#39;: &#39;image/jpeg&#39;,
                                                                },
                                                                &#39;gt_GEN_STATUS&#39;: {
                                                                        &#39;id&#39;: str(uuid.uuid4()),
                                                                        &#39;type&#39;: &#39;scalar&#39;,
                                                                },
                                                        },
                                                }
                                        },
                                }
                        ],
                }

                formdata = aiohttp.FormData()
                formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps(settings), content_type=&#39;form-data&#39;)

                new_headers = dict(self.headers)
                new_headers[&#39;x-session-id&#39;] = self.session[&#39;id&#39;]
                new_headers[&#39;x-transaction-id&#39;] = str(uuid.uuid4())
                new_headers[&#39;prefer&#39;] = &#39;respond-sync, wait=100&#39;

                async with aiohttp.ClientSession(headers=new_headers) as s:
                        async with s.post(url, headers=new_headers, data=formdata) as resp:
                                if resp.status == 401:
                                        raise Unauthorized(&#39;Unauthorized. Bearer auth token is invalid.&#39;)
                                reader = _Latin1MultipartReader(resp.headers, resp.content)
                                metadata = None
                                image = None
                                while True:
                                        part = await reader.next()
                                        if part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;application/json&#39;:
                                                metadata = await part.json()
                                        elif part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;image/jpeg&#39;:
                                                image = await part.read(decode=False)
                                        if metadata and image:
                                                break

                                # Check if the image generation was successful
                                Firefly._check_gen_status(metadata)

                                gen_options = {
                                        &#39;seed&#39;: seed,
                                        &#39;style_prompt&#39;: kwargs.get(&#39;style_prompt&#39;),
                                        &#39;anchor_prompt&#39;: kwargs.get(&#39;anchor_prompt&#39;),
                                        &#39;steps&#39;: kwargs.get(&#39;steps&#39;, 40),
                                        &#39;width&#39;: kwargs.get(&#39;width&#39;, 1024),
                                        &#39;height&#39;: kwargs.get(&#39;height&#39;, 1024),
                                        &#39;fix_face&#39;: kwargs.get(&#39;fix_face&#39;, True)
                                }
                                return Result(image, metadata, &#39;jpeg&#39;, gen_options)

        async def glyph_to_image(self, glyph: bytes, **kwargs) -&gt; Result:
                &#39;&#39;&#39;
                Generates an image from a glyph (webp image data) and prompt.

                Parameters
                ----------
                glyph: bytes
                        The glyph to use. Must be a webp image (bytes). The non-transparent pixels will be filled in by Adobe Firefly.
                description: str
                        Describe the text/fill effects you want to generate.
                seed: int, optional
                        The seed for the image generation. Default is random.
                steps: int, optional
                        The number of inference steps. Default is 30.
                width: int, optional
                        The width of the image. Default is 1024.
                height: int, optional
                        The height of the image. Default is 1024.
                pad_ratio: float, optional
                        The padding ratio. Default is 0.5.
                strength: float, optional
                        between 0.0 and 1.0, higher values cause more variations but potentially inconsistent outcomes. Default is 0.5. See https://github.com/CompVis/stable-diffusion/blob/main/README.md for more info.

                Returns
                -------
                pyfirefly.Result
                
                Raises
                ------
                pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied
                &#39;&#39;&#39;
                if not self.has_time_left:
                        raise SessionExpired(&#39;Create a new session using `await create_session()`. You can check for time left using `has_time_left`.&#39;)

                if not kwargs.get(&#39;description&#39;):
                        raise ValueError(&#39;You must provide a description.&#39;)

                url = f&#39;{self.base}v2/predict&#39;

                seed = kwargs.get(&#39;seed&#39;, random.randint(0, 100000))
                advanced_options = { &#39;num_inference_steps&#39;: kwargs.get(&#39;steps&#39;, 30) }

                settings = {
                        &#34;sensei:name&#34;: &#34;SelectionParse v2&#34;,
                        &#34;sensei:invocation_mode&#34;: &#34;synchronous&#34;,
                        &#34;sensei:invocation_batch&#34;: False,
                        &#34;sensei:in_response&#34;: False,
                        &#34;sensei:engines&#34;: [
                                {
                                        &#34;sensei:execution_info&#34;: {
                                                &#34;sensei:engine&#34;: self.engine
                                        },
                                        &#34;sensei:inputs&#34;: {
                                                &#34;gi_GLYPHMASK&#34;: {
                                                        &#34;dc:format&#34;: &#34;image/webp&#34;,
                                                        &#34;sensei:multipart_field_name&#34;: &#34;gi_GLYPHMASK&#34;,
                                                }
                                        },
                                        &#34;sensei:outputs&#34;: {
                                                &#34;spl:response&#34;: {
                                                        &#34;dc:format&#34;: &#34;application/json&#34;,
                                                        &#34;sensei:multipart_field_name&#34;: &#34;spl:response&#34;,
                                                },
                                                &#34;gi_GEN_IMAGE&#34;: {
                                                        &#34;dc:format&#34;: &#34;image/webp&#34;,
                                                        &#34;sensei:multipart_field_name&#34;: &#34;outfile&#34;,
                                                },
                                        },
                                        &#34;sensei:params&#34;: {
                                                &#34;spl:request&#34;: {
                                                        &#34;graph&#34;: {&#34;uri&#34;: &#34;urn:graph:Glyph2Image_v2&#34;},
                                                        &#34;params&#34;: [
                                                                {&#34;name&#34;: &#34;gi_SEED&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: seed},
                                                                {&#34;name&#34;: &#34;gi_NUM_STEPS&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;steps&#39;, 30) },
                                                                {&#34;name&#34;: &#34;gi_OUTPUT_WIDTH&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;width&#39;, 1024) },
                                                                {&#34;name&#34;: &#34;gi_OUTPUT_HEIGHT&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;height&#39;, 1024) },
                                                                {
                                                                        &#34;name&#34;: &#34;gi_ADVANCED&#34;,
                                                                        &#34;type&#34;: &#34;string&#34;,
                                                                        &#34;value&#34;: json.dumps(advanced_options),
                                                                },
                                                                {&#34;name&#34;: &#34;gi_LANGUAGE&#34;, &#34;type&#34;: &#34;string&#34;, &#34;value&#34;: &#34;en-us&#34;},
                                                                {&#34;name&#34;: &#34;gi_PAD_RATIO&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;pad_ratio&#39;, -1)},
                                                                {&#34;name&#34;: &#34;gi_STRENGTH&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;strength&#39;, 0.5) },
                                                        ],
                                                        &#34;inputs&#34;: {
                                                                &#34;gi_PROMPT&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;string&#34;,
                                                                        &#34;value&#34;: kwargs.get(&#39;description&#39;),
                                                                },
                                                                &#34;gi_GLYPHMASK&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;image&#34;,
                                                                        &#34;mimeType&#34;: &#34;image/webp&#34;,
                                                                },
                                                        },
                                                        &#34;outputs&#34;: {
                                                                &#34;gi_GEN_IMAGE&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;image&#34;,
                                                                        &#34;expectedMimeType&#34;: &#34;image/webp&#34;,
                                                                },
                                                                &#34;gi_GEN_STATUS&#34;: {
                                                                        &#34;id&#34;: str(uuid.uuid4()),
                                                                        &#34;type&#34;: &#34;scalar&#34;,
                                                                },
                                                        },
                                                }
                                        },
                                }
                        ],
                }

                formdata = aiohttp.FormData()
                formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps(settings), content_type=&#39;form-data&#39;)
                formdata.add_field(&#39;gi_GLYPHMASK&#39;, glyph, filename=&#39;blob&#39;, content_type=&#39;image/webp&#39;)

                new_headers = dict(self.headers)
                new_headers[&#39;x-session-id&#39;] = self.session[&#39;id&#39;]
                new_headers[&#39;x-transaction-id&#39;] = str(uuid.uuid4())
                new_headers[&#39;prefer&#39;] = &#39;respond-sync, wait=100&#39;

                async with aiohttp.ClientSession(headers=new_headers) as s:
                        async with s.post(url, headers=new_headers, data=formdata) as resp:
                                if resp.status == 401:
                                        raise Unauthorized(&#39;Unauthorized. Bearer auth token is invalid.&#39;)
                                reader = _Latin1MultipartReader(resp.headers, resp.content)
                                metadata = None
                                image = None
                                while True:
                                        part = await reader.next()
                                        if part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;application/json&#39;:
                                                metadata = await part.json()
                                        elif part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;image/webp&#39;:
                                                image = await part.read(decode=False)
                                        if metadata and image:
                                                break

                                # Check if the image generation was successful
                                Firefly._check_gen_status(metadata)

                                gen_options = {
                                        &#39;description&#39;: kwargs.get(&#39;description&#39;),
                                        &#39;seed&#39;: seed,
                                        &#39;steps&#39;: kwargs.get(&#39;steps&#39;, 30),
                                        &#39;width&#39;: kwargs.get(&#39;width&#39;, 1024),
                                        &#39;height&#39;: kwargs.get(&#39;height&#39;, 1024),
                                        &#39;pad_ratio&#39;: kwargs.get(&#39;pad_ratio&#39;, -1),
                                        &#39;strength&#39;: kwargs.get(&#39;strength&#39;, 0.5)
                                }
                                return Result(image, metadata, &#39;webp&#39;, gen_options)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyfirefly.Firefly.ASSET_BASE_URL"><code class="name">var <span class="ident">ASSET_BASE_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyfirefly.Firefly.DIFFUSION_ENGINES"><code class="name">var <span class="ident">DIFFUSION_ENGINES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyfirefly.Firefly.URLS"><code class="name">var <span class="ident">URLS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyfirefly.Firefly.base"><code class="name">var <span class="ident">base</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Firefly.engine"><code class="name">var <span class="ident">engine</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Firefly.has_time_left"><code class="name">var <span class="ident">has_time_left</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether the session has time left.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_time_left(self) -&gt; bool:
        &#39;&#39;&#39;
        Whether the session has time left.
        &#39;&#39;&#39;
        return time.time() - self.session[&#39;expires_at&#39;] &lt;= 0</code></pre>
</details>
</dd>
<dt id="pyfirefly.Firefly.headers"><code class="name">var <span class="ident">headers</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Firefly.image_styles"><code class="name">var <span class="ident">image_styles</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Firefly.session"><code class="name">var <span class="ident">session</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Firefly.text_fonts"><code class="name">var <span class="ident">text_fonts</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Firefly.text_presets"><code class="name">var <span class="ident">text_presets</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyfirefly.Firefly.create_session"><code class="name flex">
<span>async def <span class="ident">create_session</span></span>(<span>self, duration: int = 3600) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a session.</p>
<h2 id="parameters">Parameters</h2>
<p>duration: The duration of the session in seconds.</p>
<h2 id="returns">Returns</h2>
<p>The session ID string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def create_session(self, duration:int = 3600) -&gt; str:
        &#39;&#39;&#39;
        Creates a session.

        Parameters
        ----------
        duration: The duration of the session in seconds.

        Returns
        -------
        The session ID string.
        &#39;&#39;&#39;
        url = f&#39;{self.base}session/create&#39;

        formdata = aiohttp.FormData()
        formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps({&#39;session_ttl&#39;:duration}), content_type=&#39;form-data&#39;)

        async with aiohttp.ClientSession(headers=self.headers) as s:
                async with s.post(url, data=formdata) as resp:
                        if resp.status == 401:
                                raise Unauthorized(&#39;Bearer auth token is invalid.&#39;)
                        self.session[&#39;id&#39;] = resp.headers.get(&#39;x-session-id&#39;, &#39;&#39;)
                        if self.session[&#39;id&#39;]:
                                self.session[&#39;expires_at&#39;] = time.time() + duration
                        return self.session[&#39;id&#39;]</code></pre>
</details>
</dd>
<dt id="pyfirefly.Firefly.glyph_to_image"><code class="name flex">
<span>async def <span class="ident">glyph_to_image</span></span>(<span>self, glyph: bytes, **kwargs) ‑> <a title="pyfirefly.Result" href="#pyfirefly.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generates an image from a glyph (webp image data) and prompt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>glyph</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The glyph to use. Must be a webp image (bytes). The non-transparent pixels will be filled in by Adobe Firefly.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>Describe the text/fill effects you want to generate.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The seed for the image generation. Default is random.</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of inference steps. Default is 30.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the image. Default is 1024.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The height of the image. Default is 1024.</dd>
<dt><strong><code>pad_ratio</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The padding ratio. Default is 0.5.</dd>
<dt><strong><code>strength</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>between 0.0 and 1.0, higher values cause more variations but potentially inconsistent outcomes. Default is 0.5. See <a href="https://github.com/CompVis/stable-diffusion/blob/main/README.md">https://github.com/CompVis/stable-diffusion/blob/main/README.md</a> for more info.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pyfirefly.Result" href="#pyfirefly.Result">Result</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def glyph_to_image(self, glyph: bytes, **kwargs) -&gt; Result:
        &#39;&#39;&#39;
        Generates an image from a glyph (webp image data) and prompt.

        Parameters
        ----------
        glyph: bytes
                The glyph to use. Must be a webp image (bytes). The non-transparent pixels will be filled in by Adobe Firefly.
        description: str
                Describe the text/fill effects you want to generate.
        seed: int, optional
                The seed for the image generation. Default is random.
        steps: int, optional
                The number of inference steps. Default is 30.
        width: int, optional
                The width of the image. Default is 1024.
        height: int, optional
                The height of the image. Default is 1024.
        pad_ratio: float, optional
                The padding ratio. Default is 0.5.
        strength: float, optional
                between 0.0 and 1.0, higher values cause more variations but potentially inconsistent outcomes. Default is 0.5. See https://github.com/CompVis/stable-diffusion/blob/main/README.md for more info.

        Returns
        -------
        pyfirefly.Result
        
        Raises
        ------
        pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied
        &#39;&#39;&#39;
        if not self.has_time_left:
                raise SessionExpired(&#39;Create a new session using `await create_session()`. You can check for time left using `has_time_left`.&#39;)

        if not kwargs.get(&#39;description&#39;):
                raise ValueError(&#39;You must provide a description.&#39;)

        url = f&#39;{self.base}v2/predict&#39;

        seed = kwargs.get(&#39;seed&#39;, random.randint(0, 100000))
        advanced_options = { &#39;num_inference_steps&#39;: kwargs.get(&#39;steps&#39;, 30) }

        settings = {
                &#34;sensei:name&#34;: &#34;SelectionParse v2&#34;,
                &#34;sensei:invocation_mode&#34;: &#34;synchronous&#34;,
                &#34;sensei:invocation_batch&#34;: False,
                &#34;sensei:in_response&#34;: False,
                &#34;sensei:engines&#34;: [
                        {
                                &#34;sensei:execution_info&#34;: {
                                        &#34;sensei:engine&#34;: self.engine
                                },
                                &#34;sensei:inputs&#34;: {
                                        &#34;gi_GLYPHMASK&#34;: {
                                                &#34;dc:format&#34;: &#34;image/webp&#34;,
                                                &#34;sensei:multipart_field_name&#34;: &#34;gi_GLYPHMASK&#34;,
                                        }
                                },
                                &#34;sensei:outputs&#34;: {
                                        &#34;spl:response&#34;: {
                                                &#34;dc:format&#34;: &#34;application/json&#34;,
                                                &#34;sensei:multipart_field_name&#34;: &#34;spl:response&#34;,
                                        },
                                        &#34;gi_GEN_IMAGE&#34;: {
                                                &#34;dc:format&#34;: &#34;image/webp&#34;,
                                                &#34;sensei:multipart_field_name&#34;: &#34;outfile&#34;,
                                        },
                                },
                                &#34;sensei:params&#34;: {
                                        &#34;spl:request&#34;: {
                                                &#34;graph&#34;: {&#34;uri&#34;: &#34;urn:graph:Glyph2Image_v2&#34;},
                                                &#34;params&#34;: [
                                                        {&#34;name&#34;: &#34;gi_SEED&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: seed},
                                                        {&#34;name&#34;: &#34;gi_NUM_STEPS&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;steps&#39;, 30) },
                                                        {&#34;name&#34;: &#34;gi_OUTPUT_WIDTH&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;width&#39;, 1024) },
                                                        {&#34;name&#34;: &#34;gi_OUTPUT_HEIGHT&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;height&#39;, 1024) },
                                                        {
                                                                &#34;name&#34;: &#34;gi_ADVANCED&#34;,
                                                                &#34;type&#34;: &#34;string&#34;,
                                                                &#34;value&#34;: json.dumps(advanced_options),
                                                        },
                                                        {&#34;name&#34;: &#34;gi_LANGUAGE&#34;, &#34;type&#34;: &#34;string&#34;, &#34;value&#34;: &#34;en-us&#34;},
                                                        {&#34;name&#34;: &#34;gi_PAD_RATIO&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;pad_ratio&#39;, -1)},
                                                        {&#34;name&#34;: &#34;gi_STRENGTH&#34;, &#34;type&#34;: &#34;scalar&#34;, &#34;value&#34;: kwargs.get(&#39;strength&#39;, 0.5) },
                                                ],
                                                &#34;inputs&#34;: {
                                                        &#34;gi_PROMPT&#34;: {
                                                                &#34;id&#34;: str(uuid.uuid4()),
                                                                &#34;type&#34;: &#34;string&#34;,
                                                                &#34;value&#34;: kwargs.get(&#39;description&#39;),
                                                        },
                                                        &#34;gi_GLYPHMASK&#34;: {
                                                                &#34;id&#34;: str(uuid.uuid4()),
                                                                &#34;type&#34;: &#34;image&#34;,
                                                                &#34;mimeType&#34;: &#34;image/webp&#34;,
                                                        },
                                                },
                                                &#34;outputs&#34;: {
                                                        &#34;gi_GEN_IMAGE&#34;: {
                                                                &#34;id&#34;: str(uuid.uuid4()),
                                                                &#34;type&#34;: &#34;image&#34;,
                                                                &#34;expectedMimeType&#34;: &#34;image/webp&#34;,
                                                        },
                                                        &#34;gi_GEN_STATUS&#34;: {
                                                                &#34;id&#34;: str(uuid.uuid4()),
                                                                &#34;type&#34;: &#34;scalar&#34;,
                                                        },
                                                },
                                        }
                                },
                        }
                ],
        }

        formdata = aiohttp.FormData()
        formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps(settings), content_type=&#39;form-data&#39;)
        formdata.add_field(&#39;gi_GLYPHMASK&#39;, glyph, filename=&#39;blob&#39;, content_type=&#39;image/webp&#39;)

        new_headers = dict(self.headers)
        new_headers[&#39;x-session-id&#39;] = self.session[&#39;id&#39;]
        new_headers[&#39;x-transaction-id&#39;] = str(uuid.uuid4())
        new_headers[&#39;prefer&#39;] = &#39;respond-sync, wait=100&#39;

        async with aiohttp.ClientSession(headers=new_headers) as s:
                async with s.post(url, headers=new_headers, data=formdata) as resp:
                        if resp.status == 401:
                                raise Unauthorized(&#39;Unauthorized. Bearer auth token is invalid.&#39;)
                        reader = _Latin1MultipartReader(resp.headers, resp.content)
                        metadata = None
                        image = None
                        while True:
                                part = await reader.next()
                                if part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;application/json&#39;:
                                        metadata = await part.json()
                                elif part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;image/webp&#39;:
                                        image = await part.read(decode=False)
                                if metadata and image:
                                        break

                        # Check if the image generation was successful
                        Firefly._check_gen_status(metadata)

                        gen_options = {
                                &#39;description&#39;: kwargs.get(&#39;description&#39;),
                                &#39;seed&#39;: seed,
                                &#39;steps&#39;: kwargs.get(&#39;steps&#39;, 30),
                                &#39;width&#39;: kwargs.get(&#39;width&#39;, 1024),
                                &#39;height&#39;: kwargs.get(&#39;height&#39;, 1024),
                                &#39;pad_ratio&#39;: kwargs.get(&#39;pad_ratio&#39;, -1),
                                &#39;strength&#39;: kwargs.get(&#39;strength&#39;, 0.5)
                        }
                        return Result(image, metadata, &#39;webp&#39;, gen_options)</code></pre>
</details>
</dd>
<dt id="pyfirefly.Firefly.text_to_image"><code class="name flex">
<span>async def <span class="ident">text_to_image</span></span>(<span>self, prompt: str, **kwargs) ‑> <a title="pyfirefly.Result" href="#pyfirefly.Result">Result</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generates an image from a text prompt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prompt</code></strong> :&ensp;<code>str</code></dt>
<dd>The text prompt.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The seed for the image generation. Default is random.</dd>
<dt><strong><code>style_prompt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The style prompt for the image generation. Default is None.</dd>
<dt><strong><code>anchor_prompt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The anchor prompt for the image generation. Default is None.</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of inference steps. Default is 40.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>,
optional</dt>
<dd>The width of the image. Default is 1024.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The height of the image. Default is 1024.</dd>
<dt><strong><code>fix_face</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fix the face. Default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pyfirefly.Result" href="#pyfirefly.Result">Result</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def text_to_image(self, prompt: str, **kwargs) -&gt; Result:
        &#39;&#39;&#39;
        Generates an image from a text prompt.

        Parameters
        ----------
        prompt: str
                The text prompt.
        seed: int, optional
                The seed for the image generation. Default is random.
        style_prompt: str, optional
                The style prompt for the image generation. Default is None.
        anchor_prompt: str, optional
                The anchor prompt for the image generation. Default is None.
        steps: int, optional
                The number of inference steps. Default is 40.
        width: int,     optional
                The width of the image. Default is 1024.
        height: int, optional
                The height of the image. Default is 1024.
        fix_face: bool, optional
                Whether to fix the face. Default is True.
        
        Returns
        -------
        pyfirefly.Result

        Raises
        ------
        pyfirefly.SessionExpired, pyfirefly.Unauthorized, pyfirefly.ImageGenerationDenied
        &#39;&#39;&#39;
        if not self.has_time_left:
                raise SessionExpired(&#39;Create a new session using `await create_session()`. You can check for time left using `has_time_left`.&#39;)

        url = f&#39;{self.base}v2/predict&#39;

        seed = kwargs.get(&#39;seed&#39;, random.randint(0, 100000))

        style_prompt = kwargs.get(&#39;style_prompt&#39;)
        anchor_prompt = kwargs.get(&#39;anchor_prompt&#39;)
        advanced_options = { &#39;num_inference_steps&#39;: kwargs.get(&#39;steps&#39;, 40) }
        if style_prompt:
                advanced_options[&#39;style_prompt&#39;] = style_prompt
        if anchor_prompt:
                advanced_options[&#39;anchor_prompt&#39;] = anchor_prompt
        
        settings = {
                &#39;sensei:name&#39;: &#39;SelectionParse v2&#39;,
                &#39;sensei:invocation_mode&#39;: &#39;synchronous&#39;,
                &#39;sensei:invocation_batch&#39;: False,
                &#39;sensei:in_response&#39;: False,
                &#39;sensei:engines&#39;: [
                        {
                                &#39;sensei:execution_info&#39;: {
                                        &#39;sensei:engine&#39;: self.engine
                                },
                                &#39;sensei:inputs&#39;: {},
                                &#39;sensei:outputs&#39;: {
                                        &#39;spl:response&#39;: {
                                                &#39;dc:format&#39;: &#39;application/json&#39;,
                                                &#39;sensei:multipart_field_name&#39;: &#39;spl:response&#39;,
                                        },
                                        &#39;gt_GEN_IMAGE&#39;: {
                                                &#39;dc:format&#39;: &#39;image/jpeg&#39;,
                                                &#39;sensei:multipart_field_name&#39;: &#39;outfile&#39;,
                                        },
                                },
                                &#39;sensei:params&#39;: {
                                        &#39;spl:request&#39;: {
                                                &#39;graph&#39;: {&#39;uri&#39;: &#39;urn:graph:Text2Image_v2&#39;},
                                                &#39;params&#39;: [
                                                        {&#39;name&#39;: &#39;gi_SEED&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: seed},
                                                        {&#39;name&#39;: &#39;gi_NUM_STEPS&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;steps&#39;, 40)},
                                                        {&#39;name&#39;: &#39;gi_OUTPUT_WIDTH&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;width&#39;, 1024)},
                                                        {&#39;name&#39;: &#39;gi_OUTPUT_HEIGHT&#39;, &#39;type&#39;: &#39;scalar&#39;, &#39;value&#39;: kwargs.get(&#39;height&#39;, 1024)},
                                                        {
                                                                &#39;name&#39;: &#39;gi_ADVANCED&#39;,
                                                                &#39;type&#39;: &#39;string&#39;,
                                                                &#39;value&#39;: json.dumps(advanced_options),
                                                        },
                                                        {&#39;name&#39;: &#39;gi_LANGUAGE&#39;, &#39;type&#39;: &#39;string&#39;, &#39;value&#39;: &#39;en-US&#39;},
                                                        {&#39;name&#39;: &#39;gi_USE_FACE_FIX&#39;, &#39;type&#39;: &#39;boolean&#39;, &#39;value&#39;: kwargs.get(&#39;fix_face&#39;, True)},
                                                ],
                                                &#39;inputs&#39;: {
                                                        &#39;gi_PROMPT&#39;: {
                                                                &#39;id&#39;: str(uuid.uuid4()),
                                                                &#39;type&#39;: &#39;string&#39;,
                                                                &#39;value&#39;: prompt,
                                                        }
                                                },
                                                &#39;outputs&#39;: {
                                                        &#39;gt_GEN_IMAGE&#39;: {
                                                                &#39;id&#39;: str(uuid.uuid4()),
                                                                &#39;type&#39;: &#39;image&#39;,
                                                                &#39;expectedMimeType&#39;: &#39;image/jpeg&#39;,
                                                        },
                                                        &#39;gt_GEN_STATUS&#39;: {
                                                                &#39;id&#39;: str(uuid.uuid4()),
                                                                &#39;type&#39;: &#39;scalar&#39;,
                                                        },
                                                },
                                        }
                                },
                        }
                ],
        }

        formdata = aiohttp.FormData()
        formdata.add_field(&#39;contentAnalyzerRequests&#39;, json.dumps(settings), content_type=&#39;form-data&#39;)

        new_headers = dict(self.headers)
        new_headers[&#39;x-session-id&#39;] = self.session[&#39;id&#39;]
        new_headers[&#39;x-transaction-id&#39;] = str(uuid.uuid4())
        new_headers[&#39;prefer&#39;] = &#39;respond-sync, wait=100&#39;

        async with aiohttp.ClientSession(headers=new_headers) as s:
                async with s.post(url, headers=new_headers, data=formdata) as resp:
                        if resp.status == 401:
                                raise Unauthorized(&#39;Unauthorized. Bearer auth token is invalid.&#39;)
                        reader = _Latin1MultipartReader(resp.headers, resp.content)
                        metadata = None
                        image = None
                        while True:
                                part = await reader.next()
                                if part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;application/json&#39;:
                                        metadata = await part.json()
                                elif part.headers[aiohttp.hdrs.CONTENT_TYPE] == &#39;image/jpeg&#39;:
                                        image = await part.read(decode=False)
                                if metadata and image:
                                        break

                        # Check if the image generation was successful
                        Firefly._check_gen_status(metadata)

                        gen_options = {
                                &#39;seed&#39;: seed,
                                &#39;style_prompt&#39;: kwargs.get(&#39;style_prompt&#39;),
                                &#39;anchor_prompt&#39;: kwargs.get(&#39;anchor_prompt&#39;),
                                &#39;steps&#39;: kwargs.get(&#39;steps&#39;, 40),
                                &#39;width&#39;: kwargs.get(&#39;width&#39;, 1024),
                                &#39;height&#39;: kwargs.get(&#39;height&#39;, 1024),
                                &#39;fix_face&#39;: kwargs.get(&#39;fix_face&#39;, True)
                        }
                        return Result(image, metadata, &#39;jpeg&#39;, gen_options)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyfirefly.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
<span>(</span><span>image: bytes, metadata: dict, ext: str, img_options: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a result from the Adobe Firefly API.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The image data.</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code></dt>
<dd>The image extension.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>The metadata.</dd>
<dt><strong><code>img_options</code></strong> :&ensp;<code>dict</code></dt>
<dd>The image options that were used to generate the image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Result:
        &#39;&#39;&#39;
        Represents a result from the Adobe Firefly API.

        Parameters
        ----------
        image: bytes
                The image data.
        ext: str
                The image extension.
        metadata: dict
                The metadata.
        img_options: dict
                The image options that were used to generate the image.
        &#39;&#39;&#39;
        __slots__ = [&#39;image&#39;, &#39;ext&#39;, &#39;metadata&#39;, &#39;img_options&#39;]
        def __init__(self, image: bytes, metadata: dict, ext: str, img_options: dict):
                self.image = image
                self.ext = ext
                self.metadata = metadata
                self.img_options = img_options</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyfirefly.Result.ext"><code class="name">var <span class="ident">ext</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Result.image"><code class="name">var <span class="ident">image</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Result.img_options"><code class="name">var <span class="ident">img_options</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pyfirefly.Result.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyfirefly.exceptions" href="exceptions.html">pyfirefly.exceptions</a></code></li>
<li><code><a title="pyfirefly.utils" href="utils.html">pyfirefly.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyfirefly.Firefly" href="#pyfirefly.Firefly">Firefly</a></code></h4>
<ul class="two-column">
<li><code><a title="pyfirefly.Firefly.ASSET_BASE_URL" href="#pyfirefly.Firefly.ASSET_BASE_URL">ASSET_BASE_URL</a></code></li>
<li><code><a title="pyfirefly.Firefly.DIFFUSION_ENGINES" href="#pyfirefly.Firefly.DIFFUSION_ENGINES">DIFFUSION_ENGINES</a></code></li>
<li><code><a title="pyfirefly.Firefly.URLS" href="#pyfirefly.Firefly.URLS">URLS</a></code></li>
<li><code><a title="pyfirefly.Firefly.base" href="#pyfirefly.Firefly.base">base</a></code></li>
<li><code><a title="pyfirefly.Firefly.create_session" href="#pyfirefly.Firefly.create_session">create_session</a></code></li>
<li><code><a title="pyfirefly.Firefly.engine" href="#pyfirefly.Firefly.engine">engine</a></code></li>
<li><code><a title="pyfirefly.Firefly.glyph_to_image" href="#pyfirefly.Firefly.glyph_to_image">glyph_to_image</a></code></li>
<li><code><a title="pyfirefly.Firefly.has_time_left" href="#pyfirefly.Firefly.has_time_left">has_time_left</a></code></li>
<li><code><a title="pyfirefly.Firefly.headers" href="#pyfirefly.Firefly.headers">headers</a></code></li>
<li><code><a title="pyfirefly.Firefly.image_styles" href="#pyfirefly.Firefly.image_styles">image_styles</a></code></li>
<li><code><a title="pyfirefly.Firefly.session" href="#pyfirefly.Firefly.session">session</a></code></li>
<li><code><a title="pyfirefly.Firefly.text_fonts" href="#pyfirefly.Firefly.text_fonts">text_fonts</a></code></li>
<li><code><a title="pyfirefly.Firefly.text_presets" href="#pyfirefly.Firefly.text_presets">text_presets</a></code></li>
<li><code><a title="pyfirefly.Firefly.text_to_image" href="#pyfirefly.Firefly.text_to_image">text_to_image</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyfirefly.Result" href="#pyfirefly.Result">Result</a></code></h4>
<ul class="">
<li><code><a title="pyfirefly.Result.ext" href="#pyfirefly.Result.ext">ext</a></code></li>
<li><code><a title="pyfirefly.Result.image" href="#pyfirefly.Result.image">image</a></code></li>
<li><code><a title="pyfirefly.Result.img_options" href="#pyfirefly.Result.img_options">img_options</a></code></li>
<li><code><a title="pyfirefly.Result.metadata" href="#pyfirefly.Result.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>